---
layout: base
title: Scan QR code
svgicons: fa-camera, fa-pencil
additional_js: /assets/openpgpjs-v4.10.10/openpgp.min.js
---
<style>
    #scanner {
        display: inline-block;
        width: 300px;
        height: 300px;
    }
    #start-scan {
        width: 100%;
        height: 100%;
    }
    #start-scan .svgicon {
        font-size: 500%;
    }
    #scanner-image {
        border: 2px solid blue;
        width: 100%;
        height: 100%;
    }
    #scanner-settings {
        display: inline-block;
        width: 100%;
        max-width: 300px;
    }
</style>

<div class="container">

    <!-- Results -->
    <div class="row mb-3">
        <div class="col-sm-10 offset-sm-1 col-md-8 offset-md-2 col-lg-6 offset-lg-3">
            <div id="scan-internalOnly" class="scan-result alert alert-warning mt-4 text-center d-none" role="alert">
                <strong>WARNING:</strong>
                You are on an internal scan page.
                <br>
                Only QR codes you issued will scan correctly.
                <br>
                To go to the public scan page,
                <a href="{{ '/scan' | relative_url }}">click here</a>.
            </div>
            <div id="scan-pending" class="scan-result alert alert-info mt-4 text-center d-none" role="alert">
                Verifying...
            </div>
            <div id="scan-invalidFormat" class="scan-result alert alert-danger alert-dismissible fade show mt-4 text-center d-none" role="alert">
                This doesn't appear to be a verification QR code
                <button type="button" class="btn-close" aria-label="Close"></button>
            </div>
            <div id="scan-internalOnlyError" class="scan-result alert alert-danger alert-dismissible fade show mt-4 text-center d-none" role="alert">
                This QR code is for INTERNAL USE ONLY.
                <br>
                It must be scanned from the issuer's internal scan page.
                <button type="button" class="btn-close" aria-label="Close"></button>
            </div>
            <div id="scan-lookupError" class="scan-result alert alert-danger alert-dismissible fade show mt-4 text-center d-none" role="alert">
                The QR code issuer (<code id="lookupError-issuer">unknown</code>) isn't recognized
                <button type="button" class="btn-close" aria-label="Close"></button>
            </div>
            <div id="scan-invalidSignature" class="scan-result alert alert-danger alert-dismissible fade show mt-4 text-sm-center d-none" role="alert">
                <div>
                    This QR code is not valid.
                </div>
                <div class="mt-1">
                    Please request a new QR code from the issuer.
                </div>
                <button type="button" class="btn-close" aria-label="Close"></button>
            </div>
            <div id="scan-expiredSignature" class="scan-result alert alert-danger alert-dismissible fade show mt-4 text-sm-center d-none" role="alert">
                <div>
                    This QR code has expired.
                </div>
                <div class="mt-1">
                    Please request a new QR code from the issuer.
                </div>
                <button type="button" class="btn-close" aria-label="Close"></button>
            </div>
            <div id="scan-unknownError" class="scan-result alert alert-danger alert-dismissible fade show mt-4 text-center d-none" role="alert">
                Something went wrong! Please try again later.
                <button type="button" class="btn-close" aria-label="Close"></button>
            </div>
            <div id="scan-success" class="scan-result alert alert-success mt-4 text-center d-none" role="alert">
                Verified vaccine recipient!
            </div>
            <div id="scan-nondefault" class="scan-result alert alert-warning mt-4 text-sm-center d-none" role="alert">
                <div class="small">
                    Verified vaccine by
                    <a id="nondefault-groups-issuer" href="#" class="alert-link d-inline-block" target="_blank"></a>,
                    but this issuer is not trusted by default
                </div>
                <div class="mt-1">
                    Please make sure you <em>personally know and trust</em> the issuer or these groups:
                    <span id="nondefault-groups"></span>
                </div>
            </div>
            <div id="scan-no-groups" class="scan-result alert alert-warning mt-4 text-sm-center d-none" role="alert">
                <div class="small">
                    Verified vaccine, but is not part of any trusted
                    <a href="{{ '/groups' | relative_url }}" class="alert-link d-inline-block" target="_blank">groups</a>
                </div>
                <div class="mt-1">
                    Please make sure you <em>personally know and trust</em>:
                    <a id="no-groups-issuer" href="#" class="alert-link d-inline-block" target="_blank"></a>
                </div>
            </div>
            <div id="scan-manual-pubkey" class="scan-result alert alert-warning mt-4 text-sm-center d-none" role="alert">
                <div class="small">
                    Verified vaccine (for internal purposes only)
                </div>
                <div class="mt-1">
                    If you didn't generate this QR code, DO NOT TRUST IT
                </div>
            </div>
            <div id="results-wrapper" class="scan-result d-none">
                <h3>
                    Contents:
                </h3>
                <code id="results-value" class="d-block" style="overflow-y: auto; white-space: pre; font-size: 200%;"></code>
                <div class="small mt-5">
                    Issued by:
                    <a id="results-issuer" href="{{ '/issuers' | relative_url }}?id=test_arg" target="_blank">Test ARC</a>
                    <br>
                    This issuer is trusted by these groups:
                    <span id="results-groups"></span>
                </div>
                <div id="expires-wrapper" class="small d-none">
                    Expires:
                    <span id="expires"></span>
                    <span id="expires-human" class="small text-muted ps-1"></span>
                </div>
                <div class="small fst-italic mt-3">
                    <div class="text-decoration-underline">
                        WARNING: QR codes are just pieces of paper!
                    </div>
                    <div class="mt-1">
                        Always check the above information against a person's
                        government-issued ID before believing it.
                    </div>
                </div>
                <hr>
            </div>
            <div id="scan-another-wrapper" class="scan-result mb-3 text-center d-none">
                <a
                    id="scan-another-page-refresh"
                    href="{{ '/scan' | relative_url }}"
                    class="btn btn-outline-primary d-none"
                >Scan Another QR Code</a>
                <button
                    id="scan-another"
                    type="button"
                    class="btn btn-outline-primary"
                    data-bs-toggle="collapse"
                    data-bs-target="#input-options"
                    aria-expanded="false"
                    aria-controls="input-options"
                >Scan Another QR Code</button>
            </div>
        </div>
    </div>

    <!-- Input Options -->
    <div id="input-options" class="collapse show">

        <!-- Scanner -->
        <div class="text-center pt-4">
            <div id="scanner">
                <!-- Scanner icon -->
                <button id="start-scan" type="button" class="scanner-piece btn btn-outline-primary p-5">
                    <div>
                        <svg class="svgicon"><use href="#fa-camera"/></svg>
                    </div>
                    <h3 class="text-decoration-underline mt-3">
                        Scan QR Code
                    </h3>
                </button>

                <!-- Scanner image -->
                <canvas id="scanner-image" class="scanner-piece d-none"></canvas>
            </div>
        </div>
        <!-- Scanner Settings -->
        <div id="scanner-settings-wrapper" class="text-center mt-1 mb-3 d-none">
            <div id="scanner-settings">
                <!-- Camera errors (detecting, loading, permissions, etc.) -->
                <div id="scanner-load-error" class="scanner-piece text-danger d-none" role="status">
                    No camera or webcam detected
                </div>

                <!-- Camera toggles (stop, gain, etc.) -->
                <div id="scanner-toggles" class="scanner-piece text-danger d-none" role="status">
                    <button id="scanner-stop-toggle" type="button" class="btn btn-link btn-sm">Click here to stop scanner</button>
                    <button id="scanner-start-toggle" type="button" class="btn btn-link btn-sm">Click here to start scanner again</button>
                </div>
            </div>
        </div>

        <!-- Options below scanner icon -->
        <div class="row justify-content-center mt-2 mb-4">
            <div class="col-auto text-center">
                <p class="fst-italic">
                    Use your phone camera or webcam to scan a QR code<br class="d-none d-sm-inline">
                    to verify someone got their Covid-19 vaccine.
                </p>
                <p class="fst-italic">
                    Don't have a camera? No problem!<br>
                    <a data-bs-toggle="modal" data-bs-target="#image-upload-modal" href="#" role="button">Upload an image of the QR code</a><br>
                    or <a data-bs-toggle="modal" data-bs-target="#manual-entry-modal" href="#" role="button">type in the verification URL</a>
                </p>
                <p class="fst-italic">
                    Already got your Covid-19 vaccine and want a QR code?<br>
                    <a href="{{ '/issuers' | relative_url }}">Request a QR code from an issuer here</a>
                </p>
            </div>
        </div>
    </div>

</div>

<!-- Modal: Ask to start scanner (for getting user interaction on iOS) -->
<div class="modal fade" id="play-video-modal" tabindex="-1" aria-labelledby="image-upload-title" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="image-upload-title">Start QR Code Scanner</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body text-center">
                <button id="play-video" type="button" class="btn btn-primary btn-lg">Start QR Code Scanner</button>
            </div>
        </div>
    </div>
</div>

<!-- Modal: Image upload -->
<div class="modal fade" id="image-upload-modal" tabindex="-1" aria-labelledby="image-upload-title" aria-hidden="true">
    <div class="modal-dialog">
        <form id="image-upload-form" class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="image-upload-title">Upload an image of a QR code</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <label for="image-upload" class="form-label">Select image file:</label>
                <input
                    type="file"
                    class="form-control"
                    id="image-upload"
                    aria-describedby="image-upload-help">
                <div id="image-upload-error" class="invalid-feedback d-block">
                    &nbsp;
                </div>
                <div id="image-upload-help" class="form-text">
                    Most common image formats work (png, jpg, gif),
                    as long as there's a clear view of the QR code.
                </div>
            </div>
            <div class="modal-footer">
                <button id="image-upload-submit" type="submit" class="btn btn-primary">Scan Image</button>
                <button type="button" class="btn btn-link" data-bs-dismiss="modal">Nevermind</button>
            </div>
        </form>
    </div>
</div>

<!-- Modal: Manual code entry -->
<div class="modal fade" id="manual-entry-modal" tabindex="-1" aria-labelledby="manual-entry-title" aria-hidden="true">
    <div class="modal-dialog">
        <form id="manual-entry-form" class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="manual-entry-title">Manually enter a verification URL</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <label for="manual-code-entry" class="form-label">Verification URL</label>
                <input
                    class="form-control"
                    id="manual-code-entry"
                    aria-describedby="code-entry-help"
                    placeholder="(e.g. {{ site.root_url }}/scan#v1/abc123...)">
                <div id="code-entry-error" class="invalid-feedback d-block">
                    &nbsp;
                </div>
                <div id="code-entry-help" class="form-text">
                    If you have a link instead of a QR code, copy-paste it above.
                </div>
            </div>
            <div class="modal-footer">
                <button id="verify-code" type="submit" class="btn btn-primary">Verify Code</button>
                <button type="button" class="btn btn-link" data-bs-dismiss="modal">Nevermind</button>
            </div>
        </form>
    </div>
</div>

<!-- Javacript functionality -->
<script>
    "use strict";

    /**********************/
    /** Helper functions **/
    /**********************/

    // convert base64 (url-safe or not) to Uint8Array
    function fromB64(b64) {
        // convert url-safe base64 strings to normal base64 strings
        b64 = b64.replace(/-/g, "+").replace(/_/g, "/") + "==".slice(2 - (b64.length & 3));
        // convert base64 to binary string
        let bStr = window.atob(b64);
        // create byte array from binary string
        let bArr = new Uint8Array(bStr.length);
        for (let i = 0; i < bStr.length; i++) {
            bArr[i] = bStr.charCodeAt(i);
        }
        return bArr;
    }

    // convert a Uint8Array to url-safe base64 string
    function toB64(bArr) {
        // convert to binary string
        let bStr = String.fromCharCode.apply(null, bArr);
        // convert to normal base64
        let b64 = window.btoa(bStr);
        // make url-safe
        b64 = b64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
        return b64;
    }

    // verify an openpgp signature
    //  callback argument has the format: {
    //      "valid": true|false,
    //      "verifyResult": <obj>, // optional, if was able to read pubkey+signature
    //      "verifyError", <obj>, // optional, if something else went wrong
    //  }
    function openpgpVerify(numLoops, pubkey, sig, txt, callback) {

        // fail if waiting too long for openpgp to load
        if (numLoops > 1000) {
            callback({
                "valid": false,
                "verifyError": {"msg": "timeout waiting for openpgp.js to load"},
            });
            return;
        }

        // wait for openpgp to load
        if (window.openpgp === undefined) {
            setTimeout(openpgpVerify, 200, numLoops + 1, pubkey, sig, txt, callback); // wait 0.2 sec and check again
            return;
        }

        // openpgp.js objects to keep track of
        let msg = openpgp.cleartext.fromText(txt);
        let keys = undefined;

        // ingest the public key
        openpgp.key.readArmored(pubkey)

        // ingest the detached signature
        .then(function(pkObj) {
            keys = pkObj.keys;
            return openpgp.signature.read(sig);
        })

        // verify the signature
        .then(function(sigObj) {
            return openpgp.verify({
                "message": msg,
                "signature": sigObj,
                "publicKeys": keys,
            });
        })

        // return verification results
        .then(function(verifyResult){

            // valid signature, hooray!
            let sigs = verifyResult.signatures;
            if (sigs && sigs.length === 1 && sigs[0].valid) {
                callback({
                    "valid": true,
                    "verifyResult": verifyResult,
                });
            }

            // invalid signature
            else {
                callback({
                    "valid": false,
                    "verifyResult": verifyResult,
                });
            }
        })

        // catchall
        .catch(function(verifyError) {
            callback({
                "valid": false,
                "verifyError": verifyError,
            });
        });
    }

    // image scanning
    //  callback argument has the format: {
    //      "result": "locked|success|error",
    //      "qrCode": null|"somedata",
    //  }
    let qrCallback = undefined; // set/unset each call
    function qrScan(numLoops, imageDataOrVideo, callback) {

        // fail if waiting too long for scanner to load
        if (numLoops > 1000) {
            callback({
                "result": "error",
                "qrCode": null,
                "timeout": "Waited too long for either built-in scanner or web worker scanner to load",
            });
            return;
        }

        // wait for either built-in scanner or web worker to load
        if (qrBuiltIn === undefined && qrWorker === undefined) {
            setTimeout(qrScan, 200, numLoops + 1, imageDataOrVideo, callback); // wait 0.2 sec and check again
            return;
        }

        // use browswer built-in barcode detector if possible
        if (qrBuiltIn !== undefined) {
            qrBuiltIn.detect(imageDataOrVideo)
            // successful scan of image
            .then(function(barcodes) {
                callback({
                    "result": "success",
                    "qrCode": (barcodes.length ? barcodes[0].rawValue : null),
                });
            })
            // error scanning image
            .catch(function(err) {
                callback({
                    "result": "error",
                    "qrCode": null,
                    "builtInError": err,
                });
            });
        }

        // no built-in, so use web worker to scan for qr codes
        else {
            // only allow one scan at a time
            if (qrCallback !== undefined) {
                callback({
                    "result": "locked",
                    "qrCode": null,
                });
                return;
            }
            qrCallback = callback;

            // send the image data to the worker to scan for QR codes
            qrWorker.postMessage({
                "type": "decode",
                "data": imageDataOrVideo, // assumed to be ImageData, not video
            }, [imageDataOrVideo.data.buffer]);
        }
    }
    // receive messages from the scanner worker
    function qrScanMessage(msg) {

        // skip if no callback set
        if (qrCallback === undefined) {
            return;
        }

        // successfully scanned the image for QR codes
        if (msg.data['type'] === "qrResult") {
            qrCallback({
                "result": "success",
                "qrCode": msg.data['data'],
            });
        }

        // catchall error response
        else {
            qrCallback({
                "result": "error",
                "qrCode": null,
                "workerData": msg.data,
            });
        }

        // reset callback so another scan attempt can be made
        qrCallback = undefined;
    }

    // load the browser's built-in QR code scanner, or load
    // web worker scanner if built-in scanner not available
    let qrBuiltIn = undefined; // set if available
    let qrWorker = undefined; // set as fallback if built-in scanner not available
    function qrPrep() {
        if (window.BarcodeDetector) {
            BarcodeDetector.getSupportedFormats()
            .then(function(fmts) {
                if (fmts.indexOf('qr_code') !== -1) {
                    qrBuiltIn = new BarcodeDetector({"formats": ["qr_code"]});
                }
                else {
                    throw "Built-in QR scanner not available";
                }
            })
            .catch(function(err) {
                qrWorker = new Worker("{{ '/assets/qr-scanner-e8a77de/qr-scanner-worker.min.js' | relative_url }}");
                qrWorker.addEventListener("message", qrScanMessage);
            });
        }
        else {
            qrWorker = new Worker("{{ '/assets/qr-scanner-e8a77de/qr-scanner-worker.min.js' | relative_url }}");
            qrWorker.addEventListener("message", qrScanMessage);
        }
    }
    qrPrep();

    /**************************/
    /** Internationalization **/
    /**************************/

    let PAGE_LANG = "en";
    // TODO: allow different languages


    /************************/
    /** Core Functionality **/
    /************************/

    /*
     *  These are the functions that take a code and verify it. Supported code types are listed in
     *  the master SUPPORTED_CODE_FORMATS list, and when a code is passed to the verifyCode()
     *  function, we try to match the code to the supported code type and then pass it to that
     *  code type's sub-function (e.g. verifyV1Code()).
     *
     *  Code type sub-functions need to expect 3 arguments (code, successCallback, errorCallback)
     *  and follow the expected callback argument formats (see below).
     *
     *  Success callback passed argument: {
     *      "code": "<code>",
     *      "codeType": "<code_type>",
     *      ...other key-values specific to the code type
     *  }
     *
     *  Success callback passed argument: {
     *      "error": "invalidFormat|internalOnlyError|lookupError|invalidSignature|expiredSignature",
     *      "code": "<code>",
     *      "codeType": undefined|"<code_type>", // undefined if couldn't find what type of code it was
     *      ...other key-values specific to the code type
     *  }
     */

    // Vax.Codes v1 format verifications
    // Format:
    //  {optional_url_and_settings}{version}/{issuer}/{signature_url_safe_b64}/{signed_value_percent_encoded}
    // Examples:
    //  v1/test_arc/l4390gjeio238jfwkdj-lkfjwi3jfed_23j.../hello%0Aworld
    //  {{ site.root_url }}/scan#v1/test_arc/l4390gjeio238jfwkdj-lkfjwi3jfed_23j.../hello%0Aworld
    const vaxCodesV1MatchRegex = new RegExp("^(.*)v1/([^/#]+)/([a-zA-Z0-9-_]+)/([^/#]+)$");
    const vaxCodesV1CodeType = "vax-codes-v1";
    function vaxCodesV1Verify(code, successCallback, errorCallback) {

        // break out the code into groups
        const codeGroups = code.match(vaxCodesV1MatchRegex);
        if (codeGroups === null) {
            errorCallback({
                "error": "invalidFormat",
                "code": code,
                "codeType": vaxCodesV1CodeType,
                "errorType": "regexMismatch",
            });
            return;
        }

        // define the verification parameters
        let urlAndSettings = codeGroups[1];
        let issuerId = codeGroups[2];
        let signatureB64 = codeGroups[3];
        let unverifiedContent = decodeURIComponent(codeGroups[4]);

        // convert the base64 signature to bytes
        let signature = undefined;
        try {
            signature = fromB64(signatureB64);
        } catch(err) {
            errorCallback({
                "error": "invalidFormat",
                "code": code,
                "codeType": vaxCodesV1CodeType,
                "errorType": "sigDecodeError",
                "b64DecodeError": err,
            });
            return;
        }

        // see if we should use a non-default API
        // e.g. "{{ site.root_url }}/scan#api=<api_endpoint>"
        let vaxCodesV1IssuersAPI = "api/v1/issuers"; // default api endpoint root
        let overrideAPI = window.location.href.match(/#(?:[^#]+\/|)api=([^#=\/]+)/);
        if (overrideAPI !== null) {
            vaxCodesV1IssuersAPI = overrideAPI[1];
        }

        // see if we should only trust a specific public key
        // e.g. "{{ site.root_url }}/scan#pubkey=<base64_encoded_pgp_key>"
        let vaxCodesV1TrustedPubkey = undefined; // default is no override public key
        let overridePubkey = window.location.href.match(/#(?:[^#]+\/|)pubkey=([^#=\/]+)/);
        if (overridePubkey !== null) {
            try {
                vaxCodesV1TrustedPubkey = window.atob(overridePubkey[1]);
            } catch (err) {
                // do nothing
            }
        }

        // verify against the specifically provided key
        if (vaxCodesV1TrustedPubkey !== undefined) {
            openpgpVerify(0, vaxCodesV1TrustedPubkey, signature, unverifiedContent, function(sigResult) {
                if (sigResult['valid']) {
                    successCallback({
                        "code": code,
                        "codeType": vaxCodesV1CodeType,
                        "sigResult": sigResult,
                        //"keyIndex": 0,    // no issuer details for specifically provided pubkeys
                        //"issuer": {...},  // no issuer details for specifically provided pubkeys
                    });
                }
                else if (
                    sigResult.verifyResult
                    && sigResult.verifyResult.signatures
                    && sigResult.verifyResult.signatures.length === 1
                    && sigResult.verifyResult.signatures[0].error
                    && sigResult.verifyResult.signatures[0].error.message === "Signature is expired"
                ) {
                    errorCallback({
                        "error": "expiredSignature",
                        "code": code,
                        "codeType": vaxCodesV1CodeType,
                        "errorType": "manualVerifyFail",
                        "sigResult": sigResult,
                    });
                }
                else {
                    errorCallback({
                        "error": "invalidSignature",
                        "code": code,
                        "codeType": vaxCodesV1CodeType,
                        "errorType": "manualVerifyFail",
                        "sigResult": sigResult,
                    });
                }
            });
        }
        // marked for internal-only use
        else if (issuerId === "INTERNAL_ONLY") {
            errorCallback({
                "error": "internalOnlyError",
                "code": code,
                "codeType": vaxCodesV1CodeType,
            });
        }
        // look up the issuer's public keys from the api
        else {
            const xhr = new XMLHttpRequest();
            xhr.open("GET", vaxCodesV1IssuersAPI + "/" + issuerId + ".json");
            xhr.onreadystatechange = function() {
                if(xhr.readyState === XMLHttpRequest.DONE) {

                    // request error (non-2XX response (or 0 for local filesystems))
                    if (!(xhr.status === 0 || (xhr.status >= 200 && xhr.status < 300))) {
                        errorCallback({
                            "error": "lookupError",
                            "code": code,
                            "codeType": vaxCodesV1CodeType,
                            "errorType": "issuerLookupFailure",
                            "issuerId": issuerId,
                            "responseStatus": xhr.status,
                            "responseText": xhr.responseText,
                        });
                        return;
                    }

                    // load issuer
                    let issuer = undefined;
                    let foundExpiredSignature = false;
                    try {
                        issuer = JSON.parse(xhr.responseText);
                    }
                    catch(err) {
                        errorCallback({
                            "error": "lookupError",
                            "code": code,
                            "codeType": vaxCodesV1CodeType,
                            "errorType": "jsonDecodeError",
                            "issuerId": issuerId,
                            "errorObj": err,
                            "responseStatus": xhr.status,
                            "responseText": xhr.responseText,
                        });
                        return;
                    }

                    // start scanning keys for valid signature
                    function _tryIssuerKey(curIndex) {

                        // no more public keys, so give up
                        if (issuer['keys'][curIndex] === undefined || curIndex > 100) {
                            errorCallback({
                                "error": foundExpiredSignature ? "expiredSignature" : "invalidSignature",
                                "code": code,
                                "codeType": vaxCodesV1CodeType,
                                "errorType": "triedAllPublicKeys",
                                "issuer": issuer,
                            });
                        }

                        // found another public key to try
                        else {
                            openpgpVerify(0, issuer['keys'][curIndex]['pubkey'], signature, unverifiedContent, function(sigResult){
                                // good signature
                                if (sigResult['valid']) {
                                    successCallback({
                                        "code": code,
                                        "codeType": vaxCodesV1CodeType,
                                        "sigResult": sigResult,
                                        "keyIndex": curIndex,
                                        "issuer": issuer,
                                    });
                                }
                                // invalid signature, so try the next public key
                                else {
                                    if (
                                        sigResult.verifyResult
                                        && sigResult.verifyResult.signatures
                                        && sigResult.verifyResult.signatures.length === 1
                                        && sigResult.verifyResult.signatures[0].error
                                        && sigResult.verifyResult.signatures[0].error.message === "Signature is expired"
                                    ) {
                                        foundExpiredSignature = true;
                                    }
                                    _tryIssuerKey(curIndex + 1);
                                }
                            });
                        }
                    }
                    _tryIssuerKey(0);
                }
            };
            xhr.send();
        }
    }

    // ...add more verification sub-functions for more code types here

    // supported vaccine verification code formats
    const SUPPORTED_CODE_FORMATS = [

        // Vax.Codes v1
        {
            "format": vaxCodesV1MatchRegex,
            "verifyFunction": vaxCodesV1Verify,
        },

        // ...add more supported verification code formats here
    ]

    // starting point to verify a code or url
    function verifyCode(code, successCallback, errorCallback) {

        // determine what version/type of code to verify
        for (let i = 0; i < SUPPORTED_CODE_FORMATS.length; i++) {
            let versionMatch = code.match(SUPPORTED_CODE_FORMATS[i]['format']);
            if (versionMatch !== null) {
                SUPPORTED_CODE_FORMATS[i]['verifyFunction'](code, successCallback, errorCallback);
                return;
            }
        }

        // didn't match any versions, so not a supported code
        errorCallback({"error": "invalidFormat", "code": code});
    }

    /*********************/
    /** Results Display **/
    /*********************/

    // results components
    const resultsPieces = document.querySelectorAll(".scan-result");
    const alertInternalOnly = document.getElementById("scan-internalOnly");
    const alertPending = document.getElementById("scan-pending");
    const alertInvalidFormat = document.getElementById("scan-invalidFormat");
    const alertInternalError = document.getElementById("scan-internalOnlyError");
    const alertLookupError = document.getElementById("scan-lookupError");
    const lookupErrorIssuer = document.getElementById("lookupError-issuer");
    const alertInvalidSignature = document.getElementById("scan-invalidSignature");
    const alertExpiredSignature = document.getElementById("scan-expiredSignature");
    const alertUnknownError = document.getElementById("scan-unknownError");
    const alertSuccess = document.getElementById("scan-success");
    const alertNonDefault = document.getElementById("scan-nondefault");
    const alertNoGroups = document.getElementById("scan-no-groups");
    const alertManualPubkey = document.getElementById("scan-manual-pubkey");
    const nonDefaultGroupsWrapper = document.getElementById("nondefault-groups");
    const nonDefaultGroupsIssuerLink = document.getElementById("nondefault-groups-issuer");
    const noGroupsIssuerLink = document.getElementById("no-groups-issuer");
    const resultsWrapper = document.getElementById("results-wrapper");
    const resultsValue = document.getElementById("results-value");
    const resultsIssuer = document.getElementById("results-issuer");
    const resultsGroupsWrapper = document.getElementById("results-groups");
    const expiresWrapper = document.getElementById("expires-wrapper");
    const expiresDate = document.getElementById("expires");
    const expiresHuman = document.getElementById("expires-human");
    const scanAnotherWrapper = document.getElementById("scan-another-wrapper");
    const inputOptions = document.getElementById("input-options");

    // render expires
    function renderExpires(results) {
        let hasExpiration = false;

        // for Vax.Codes v1, expirations are way down inside the OpenPGP signature packet
        if (
            results['sigResult']
            && results['sigResult']['verifyResult']
            && results['sigResult']['verifyResult']['signatures']
            && results['sigResult']['verifyResult']['signatures'].length === 1
            && results['sigResult']['verifyResult']['signatures'][0]
            && results['sigResult']['verifyResult']['signatures'][0]['signature']
            && results['sigResult']['verifyResult']['signatures'][0]['signature']['packets']
            && results['sigResult']['verifyResult']['signatures'][0]['signature']['packets'].length === 1
            && results['sigResult']['verifyResult']['signatures'][0]['signature']['packets'][0]
        ) {
            let sigPacket = results['sigResult']['verifyResult']['signatures'][0]['signature']['packets'][0];
            // has expiration
            if (sigPacket.signatureExpirationTime !== null) {
                hasExpiration = true;

                // take 1 second off so the date shows the previous day
                let expires = new Date(sigPacket.created.getTime());
                expires.setSeconds(expires.getSeconds() + sigPacket.signatureExpirationTime - 1);

                // show the actual date of expiration
                expiresWrapper.classList.remove("d-none");
                expiresDate.textContent = expires.toLocaleDateString();
                expiresDate.title = expires.toLocaleString();

                // show a human friendly relative time (inspired by https://stackoverflow.com/a/53800501)
                const humanFormat = new Intl.RelativeTimeFormat(PAGE_LANG, { numeric: 'auto' });
                const secondsPassed = expires - (new Date());
                const units = {"year" : 31536000000, "month" : 2628000000, "day" : 86400000, "hour" : 3600000, "minute" : 60000, "second" : 1000};
                for (let unit in units) {
                    if (Math.abs(secondsPassed) > units[unit] || unit === "second") {
                        expiresHuman.textContent = "(" + humanFormat.format(Math.round(secondsPassed / units[unit]), unit) + ")";
                        expiresHuman.title = expires.toISOString();
                        break;
                    }
                }
            }
        }

        // no expiration
        if (!hasExpiration) {
            expiresWrapper.classList.add("d-none");
            expiresDate.textContent = "";
            expiresDate.title = "";
            expiresHuman.textContent = "";
            expiresHuman.title = "";
        }
    }

    // show results
    function showResults(results) {

        // scroll to the top of the page
        window.scrollTo(0, 0);

        // hide any existing results
        resultsPieces.forEach(function(el) { el.classList.add("d-none"); });

        // Vax.Codes v1 results
        if (results['codeType'] === vaxCodesV1CodeType) {

            // no issuer, so must be trusting a public key in the url
            if (results['issuer'] === undefined) {

                // populate content
                resultsValue.textContent = results['sigResult']['verifyResult']['data'];
                renderExpires(results);

                // populate issuer and groups with nothing
                resultsIssuer.textContent = "FOR_INTERNAL_USE_ONLY";
                resultsIssuer.href = window.location.href;
                resultsGroupsWrapper.innerHTML = "N/A";

                // show rendered results
                alertManualPubkey.classList.remove("d-none");
                resultsWrapper.classList.remove("d-none");
                scanAnotherWrapper.classList.remove("d-none");
                inputOptions.classList.remove("show");
                return;
            }

            // see if we should trust a specific set of groups
            // e.g. "{{ site.root_url }}/scan#groups=<group_id>,<group_id>,..."
            let trustedGroupsRef = undefined; // default is only trust default groups
            let overrideGroups = window.location.href.match(/#(?:[^#]+\/|)groups=([^#=\/]+)/);
            if (overrideGroups !== null) {
                trustedGroupsRef = overrideGroups[1].split(",");
            }

            // see what groups support the issuer's public key
            const key = results['issuer']['keys'][results['keyIndex']];
            let trustedGroups = [];
            let untrustedGroups = [];
            for (let g = 0; g < key['groups'].length; g++) {
                let group = key['groups'][g];

                // skip empty groups (sometimes happens for issuers not part of any groups)
                if (group['id'] === undefined) {
                    continue;
                }

                // in a default group, and only trusting default groups (default)
                if (trustedGroupsRef === undefined && group['is_default']) {
                    trustedGroups.push(group);
                }

                // in a specifically trusted group
                else if (trustedGroupsRef !== undefined && trustedGroupsRef.indexOf(group['id']) !== -1) {
                    trustedGroups.push(group);
                }

                // default is to assume the group is untrusted
                else {
                    untrustedGroups.push(group);
                }
            }

            // issuer in a trusted group, so show a successful result
            if (trustedGroups.length > 0) {

                // populate content
                resultsValue.textContent = results['sigResult']['verifyResult']['data'];
                renderExpires(results);

                // populate issuer
                resultsIssuer.textContent = results['issuer']['name'];
                resultsIssuer.href = "{{ '/issuers' | relative_url }}?id=" + encodeURIComponent(results['issuer']['id']);

                // populate groups
                resultsGroupsWrapper.innerHTML = "";
                for (let g = 0; g < trustedGroups.length; g++) {
                    let group = trustedGroups[g];

                    // add group links
                    let groupLink = document.createElement("a");
                    groupLink.textContent = group['name'];
                    groupLink.href = "{{ '/groups' | relative_url }}?id=" + encodeURIComponent(group['id']);
                    groupLink.setAttribute("target", "_blank");
                    resultsGroupsWrapper.appendChild(groupLink);
                    if (g < (trustedGroups.length - 1)) {
                        resultsGroupsWrapper.appendChild(document.createTextNode(", "));
                    }
                }

                // show rendered results
                alertSuccess.classList.remove("d-none");
                resultsWrapper.classList.remove("d-none");
                scanAnotherWrapper.classList.remove("d-none");
                inputOptions.classList.remove("show");
            }

            // issuer in an untrusted group, so show a warning
            else if (untrustedGroups.length > 0) {

                // populate content
                resultsValue.textContent = results['sigResult']['verifyResult']['data'];
                renderExpires(results);

                // populate issuer
                resultsIssuer.textContent = results['issuer']['name'];
                resultsIssuer.href = "{{ '/issuers' | relative_url }}?id=" + encodeURIComponent(results['issuer']['id']);
                nonDefaultGroupsIssuerLink.textContent = results['issuer']['name'];
                nonDefaultGroupsIssuerLink.href = resultsIssuer.href;

                // populate groups
                nonDefaultGroupsWrapper.innerHTML = "";
                resultsGroupsWrapper.innerHTML = "";
                for (let g = 0; g < untrustedGroups.length; g++) {
                    let group = untrustedGroups[g];

                    // add alert links
                    let alertLink = document.createElement("a");
                    alertLink.textContent = group['name'];
                    alertLink.href = "{{ '/groups' | relative_url }}?id=" + encodeURIComponent(group['id']);
                    alertLink.classList.add("alert-link");
                    alertLink.classList.add("d-inline-block");
                    alertLink.setAttribute("target", "_blank");
                    nonDefaultGroupsWrapper.appendChild(alertLink);
                    if (g < (untrustedGroups.length - 1)) {
                        nonDefaultGroupsWrapper.appendChild(document.createTextNode(" or "));
                    }

                    // add non-default group links
                    let groupLink = document.createElement("a");
                    groupLink.textContent = group['name'];
                    groupLink.href = "{{ '/groups' | relative_url }}?id=" + encodeURIComponent(group['id']);
                    groupLink.setAttribute("target", "_blank");
                    resultsGroupsWrapper.appendChild(groupLink);
                    if (g < (untrustedGroups.length - 1)) {
                        resultsGroupsWrapper.appendChild(document.createTextNode(", "));
                    }
                }

                // show rendered results
                alertNonDefault.classList.remove("d-none");
                resultsWrapper.classList.remove("d-none");
                scanAnotherWrapper.classList.remove("d-none");
                inputOptions.classList.remove("show");
            }

            // issuer isn't in any groups
            else {
                // populate content
                resultsValue.textContent = results['sigResult']['verifyResult']['data'];
                renderExpires(results);

                // populate issuer
                resultsIssuer.textContent = results['issuer']['name'];
                resultsIssuer.href = "{{ '/issuers' | relative_url }}?id=" + encodeURIComponent(results['issuer']['id']);
                noGroupsIssuerLink.textContent = results['issuer']['name'];
                noGroupsIssuerLink.href = resultsIssuer.href;

                // populate groups
                resultsGroupsWrapper.innerHTML = "None";

                // show rendered results
                alertNoGroups.classList.remove("d-none");
                resultsWrapper.classList.remove("d-none");
                scanAnotherWrapper.classList.remove("d-none");
                inputOptions.classList.remove("show");
            }
        }
    }

    // non-destructive alert dismissal instead of using bootstrap's 'data-bs-dismiss="alert"' since it destroys the alert
    document.querySelectorAll(".alert > .btn-close").forEach(function(el) {
        el.addEventListener("click", function(e) {
            this.parentNode.classList.remove("show");
            setTimeout(function(alertNode) {
                alertNode.classList.add("d-none");
                alertNode.classList.add("show");
            }, 150, this.parentNode);
        });
    });

    /***********************/
    /** Manual Code Entry **/
    /***********************/

    // manual entry components
    const manualEntryModal = document.getElementById("manual-entry-modal");
    const manualEntryForm = document.getElementById("manual-entry-form");
    const manualEntryInput = document.getElementById("manual-code-entry");
    const manualEntryError = document.getElementById("code-entry-error");
    const manualEntrySubmit = document.getElementById("verify-code");

    // try to verify a copy/pasted verification code URL
    function verifyManualEntry(event) {
        event.preventDefault();

        // switch to verifying state
        manualEntrySubmit.textContent = "Verifying...";
        manualEntrySubmit.classList.add("disabled");

        // hide any previous errors
        manualEntryInput.classList.remove("is-invalid");
        manualEntryError.classList.add("invisible");

        // verify the url entered
        verifyCode(manualEntryInput.value,

            // success
            function(results) {
                // show the result
                showResults(results);

                // close the modal
                bootstrap.Modal.getInstance(manualEntryModal).hide();
            },

            // error
            function(error) {
                // code isn't in the right format
                if (error['error'] === "invalidFormat") {
                    manualEntryError.textContent = "This doesn't look like a verification URL.";
                }
                // internal only issuer
                else if (error['error'] === "internalOnlyError") {
                    manualEntryError.textContent = "This code is meant for internal use only.";
                }
                // couldn't find the issuer
                else if (error['error'] === "lookupError") {
                    manualEntryError.textContent = "The issuer of this verification couldn't be found.";
                }
                // code signature verification failed
                else if (error['error'] === "invalidSignature") {
                    manualEntryError.textContent = "This url is not valid. Please request a new one from the issuer.";
                }
                // signature has expired
                else if (error['error'] === "expiredSignature") {
                    manualEntryError.textContent = "This url has expired. Please request a new one from the issuer.";
                }
                // catch-all for unknown errors
                else {
                    manualEntryError.textContent = "Unfortunately, something went wrong :(";
                }

                // show the error
                manualEntryInput.classList.add("is-invalid");
                manualEntryError.classList.remove("invisible");

                // switch back to ready-to-submit
                manualEntrySubmit.textContent = "Verify Code";
                manualEntrySubmit.classList.remove("disabled");
            }
        );
    }
    // submit triggers
    manualEntrySubmit.addEventListener("click", verifyManualEntry);
    manualEntryForm.addEventListener("submit", verifyManualEntry);
    // reset model when it opens
    manualEntryModal.addEventListener("show.bs.modal", function(event) {

        // clear the text input
        manualEntryInput.value = "";

        // reset any errors
        manualEntryInput.classList.remove("is-invalid");
        manualEntryError.classList.add("invisible");
        manualEntryError.textContent = "";

        // reset submit button
        manualEntrySubmit.textContent = "Verify Code";
        manualEntrySubmit.classList.remove("disabled");
    });

    /*************************/
    /** Manual Image Upload **/
    /*************************/

    // manual upload components
    const imageUploadModal = document.getElementById("image-upload-modal");
    const imageUploadForm = document.getElementById("image-upload-form");
    const imageUploadInput = document.getElementById("image-upload");
    const imageUploadError = document.getElementById("image-upload-error");
    const imageUploadSubmit = document.getElementById("image-upload-submit");

    // try to scan an uploaded image
    function verifyImageUpload(event) {
        event.preventDefault();

        // switch to verifying state
        imageUploadSubmit.textContent = "Verifying...";
        imageUploadSubmit.classList.add("disabled");

        // hide any previous errors
        imageUploadInput.classList.remove("is-invalid");
        imageUploadError.classList.add("invisible");

        // error handling
        function _handleErrors(error) {
            // no file selected
            if (error['error'] === "noFile") {
                imageUploadError.textContent = "Please select an image file.";
            }
            // locked processing another image
            else if (error['error'] === "lockedScanner") {
                imageUploadError.textContent = "We're still processing another image.";
            }
            // not an image file
            else if (error['error'] === "notAnImageFile") {
                imageUploadError.textContent = "This file type isn't supported.";
            }
            // scanned image doesn't contain a QR code
            else if (error['error'] === "noCodeInImage") {
                imageUploadError.textContent = "This image doesn't appear to contain a QR code.";
            }
            // code isn't in the right format
            else if (error['error'] === "invalidFormat") {
                imageUploadError.textContent = "This doesn't look like a verification QR code.";
            }
            // internal only issuer
            else if (error['error'] === "internalOnlyError") {
                imageUploadError.textContent = "This code is meant for internal use only.";
            }
            // couldn't find the issuer
            else if (error['error'] === "lookupError") {
                imageUploadError.textContent = "The issuer of this verification couldn't be found.";
            }
            // code signature verification failed
            else if (error['error'] === "invalidSignature") {
                imageUploadError.textContent = "This QR code is not valid. Please request a new one from the issuer.";
            }
            // signature expired
            else if (error['error'] === "expiredSignature") {
                imageUploadError.textContent = "This QR code has expired. Please request a new one from the issuer.";
            }
            // catch-all for unknown errors
            else {
                imageUploadError.textContent = "Unfortunately, something went wrong :(";
            }

            // show the error
            imageUploadInput.classList.add("is-invalid");
            imageUploadError.classList.remove("invisible");

            // switch back to ready-to-submit
            imageUploadSubmit.textContent = "Scan Image";
            imageUploadSubmit.classList.remove("disabled");
        }

        // success handling
        function _handleSuccess(results) {
            // show the result
            showResults(results);

            // close the modal
            bootstrap.Modal.getInstance(imageUploadModal).hide();
        }

        // read in the image
        const imgReader = new FileReader();
        imgReader.addEventListener("load", function () {
            let img = new Image();
            img.src = imgReader.result;
            img.onerror = function() {
                _handleErrors({"error": "notAnImageFile"});
            }
            img.onload = function() {

                // create an ImageData object from the file
                let qrCanvas = document.createElement("canvas");
                qrCanvas.width = img.width;
                qrCanvas.height = img.height;
                let qrCtx = qrCanvas.getContext("2d", {"alpha": false});
                qrCtx.imageSmoothingEnabled = false;
                qrCtx.drawImage(img, 0, 0, img.width, img.height);
                let imageData = qrCtx.getImageData(0, 0, qrCanvas.width, qrCanvas.height);

                // see if there's a QR code in the image
                qrScan(0, imageData, function(scanResult) {

                    // known errors
                    if (scanResult['result'] === "locked") {
                        _handleErrors({"error": "lockedScanner"});
                    }
                    else if (scanResult['result'] === "error") {
                        _handleErrors({"error": "notAnImageFile"});
                    }
                    else if (scanResult['result'] === "success" && scanResult['qrCode'] === null) {
                        _handleErrors({"error": "noCodeInImage"});
                    }

                    // successful read, so pass it along for verification
                    else if (scanResult['result'] === "success" && scanResult['qrCode'] !== null) {
                        verifyCode(scanResult['qrCode'], _handleSuccess, _handleErrors);
                    }

                    // catchall
                    else {
                        _handleErrors({"error": "notAnImageFile"});
                    }
                });
            }

        }, false);

        // file was selected
        if (imageUploadInput.files[0]) {
            imgReader.readAsDataURL(imageUploadInput.files[0]);
        }

        // no file selected
        else {
            _handleErrors({"error": "noFile"});
        }
    }
    // submit triggers
    imageUploadSubmit.addEventListener("click", verifyImageUpload);
    imageUploadForm.addEventListener("submit", verifyImageUpload);
    // reset model when it opens
    imageUploadModal.addEventListener("show.bs.modal", function(event) {

        // clear the file selection
        imageUploadInput.value = "";

        // reset any errors
        imageUploadInput.classList.remove("is-invalid");
        imageUploadError.classList.add("invisible");
        imageUploadError.textContent = "";

        // reset submit button
        imageUploadSubmit.textContent = "Scan Image";
        imageUploadSubmit.classList.remove("disabled");
    })

    /*************/
    /** Scanner **/
    /*************/

    // various page elements
    const scannerPieces = document.querySelectorAll(".scanner-piece");
    const startScanIcon = document.getElementById("start-scan");
    const scannerSettingsWrapper = document.getElementById("scanner-settings-wrapper");
    const scannerLoadError = document.getElementById("scanner-load-error");
    const scannerToggles = document.getElementById("scanner-toggles");
    const scannerStopButton = document.getElementById("scanner-stop-toggle");
    const scannerStartButton = document.getElementById("scanner-start-toggle");
    const playVideoModal = document.getElementById("play-video-modal");
    const playVideoButton = document.getElementById("play-video");

    // camera scanner image
    const cameraVideo = document.createElement("video");
    const scannerImage = document.getElementById("scanner-image");
    const scannerImageCtx = scannerImage.getContext("2d", {"alpha": false});
    scannerImageCtx.imageSmoothingEnabled = false;

    // iOS compatibility for auto-playing
    cameraVideo.muted = true; // mute so don't need user gesture to play on iOS
    cameraVideo.disablePictureInPicture = true; // disable PnP for some reason
    cameraVideo.playsInline = true; // disable fullscreen

    // take a shared camera stream video and start scanning it for QR codes
    function startVideoScan(event) {

        // hide the manual playback toggle (if shown)
        let playModal = bootstrap.Modal.getInstance(playVideoModal) || (new bootstrap.Modal(playVideoModal));
        playModal.hide();

        // try to play the camera as video
        if (cameraVideo.paused) {
            cameraVideo.play() // returns a Promise

            // playback successful
            .then(function() {

                // show image playback controls
                scannerPieces.forEach(function(el) { el.classList.add("d-none"); });
                scannerImage.classList.remove("d-none");
                scannerSettingsWrapper.classList.remove("d-none");
                scannerToggles.classList.remove("d-none");
                scannerStopButton.classList.remove("d-none"); // show stop toggle
                scannerStartButton.classList.add("d-none"); // hide start toggle

                // start rendering and trying to scan images
                function _drawImage() {

                    // don't continue if video has stopped playing
                    if (!(cameraVideo.srcObject && cameraVideo.srcObject.getTracks() && cameraVideo.srcObject.getTracks()[0].readyState === "live")) {
                        return;
                    }

                    // draw the latest video frame
                    let minDimension = Math.min(cameraVideo.videoWidth, cameraVideo.videoHeight, 500); // 500x500 max capture area
                    let xOffset = Math.floor((cameraVideo.videoWidth - minDimension) / 2);
                    let yOffset = Math.floor((cameraVideo.videoHeight - minDimension) / 2);
                    scannerImageCtx.drawImage(cameraVideo, xOffset, yOffset, minDimension, minDimension, 0, 0, scannerImage.width, scannerImage.height);

                    // built-in barcode detectors accept video as input
                    let imageDataOrVideo = cameraVideo;
                    // worker-based detectors take image dumps from the canvas
                    if (qrBuiltIn === undefined) {
                        imageDataOrVideo = scannerImageCtx.getImageData(0, 0, scannerImage.width, scannerImage.height);
                    }

                    // see if there's a QR code in the frame
                    qrScan(0, imageDataOrVideo, function(scanResult) {

                        // successful read, so pass it along for verification
                        if (scanResult['result'] === "success" && scanResult['qrCode'] !== null) {

                            // show the verifying state
                            resultsPieces.forEach(function(el) { el.classList.add("d-none"); });
                            alertPending.classList.remove("d-none");

                            // try to verify the scanned code
                            verifyCode(scanResult['qrCode'],

                                // success
                                function(results) {
                                    // show the result
                                    showResults(results);

                                    // switch to play video toggle under captured image
                                    scannerStopButton.classList.add("d-none"); // hide stop toggle
                                    scannerStartButton.classList.remove("d-none"); // show start toggle
                                },

                                // error
                                function(error) {
                                    // hide any existing results
                                    resultsPieces.forEach(function(el) { el.classList.add("d-none"); });

                                    // scroll to the top of the page
                                    window.scrollTo(0, 0);

                                    // code isn't in the right format
                                    if (error['error'] === "invalidFormat") {
                                        alertInvalidFormat.classList.remove("d-none");
                                    }
                                    // internal only issuer
                                    else if (error['error'] === "internalOnlyError") {
                                        alertInternalError.classList.remove("d-none");
                                    }
                                    // couldn't find the issuer
                                    else if (error['error'] === "lookupError") {
                                        lookupErrorIssuer.textContent = error['issuerId'];
                                        alertLookupError.classList.remove("d-none");
                                    }
                                    // code signature verification failed
                                    else if (error['error'] === "invalidSignature") {
                                        alertInvalidSignature.classList.remove("d-none");
                                    }
                                    // signature expired
                                    else if (error['error'] === "expiredSignature") {
                                        alertExpiredSignature.classList.remove("d-none");
                                    }
                                    // catch-all for unknown errors
                                    else {
                                        alertUnknownError.classList.remove("d-none");
                                    }

                                    // switch to play video toggle under captured image
                                    scannerStopButton.classList.add("d-none"); // hide stop toggle
                                    scannerStartButton.classList.remove("d-none"); // show start toggle
                                },
                            );

                        }

                        // ignore scan errors, wait a few moments, and try again
                        else {
                            setTimeout(_drawImage, 100);
                        }
                    });
                }
                _drawImage();
            })

            // playback error
            .catch(function(error) {

                // different error messages based on what went wrong
                switch(error.name) {

                    // video playback prevented
                    case "NotAllowedError":

                        // user gesture required, so show modal asking for permission
                        let playModal = bootstrap.Modal.getInstance(playVideoModal) || (new bootstrap.Modal(playVideoModal));
                        playModal.show();

                        // show error text
                        scannerLoadError.innerHTML = `
                            <a data-bs-toggle="modal" data-bs-target="#play-video-modal" href="#" role="button">Tap here to start scanner</a><br>
                            <small>(Need user gesture: <span id="play-video-error"></span>)</small>
                        `;
                        scannerLoadError.querySelector("#play-video-error").textContent = error.message;

                        break;

                    // no devices
                    case "NotSupportedError":
                        scannerLoadError.textContent = "Video format unsupported";
                        break;

                    // catchall
                    default:
                        scannerLoadError.textContent = "Error loading video";
                }
                // show the error
                scannerSettingsWrapper.classList.remove("d-none");
                scannerLoadError.classList.remove("d-none");
            });
        }
    }
    playVideoButton.addEventListener("click", startVideoScan); // for user-gesture required situations (e.g. iOS)

    // start the camera and try to scan for QR codes
    function useCameraScanner(event) {
        event.preventDefault();

        // no media devices support at all
        if (!navigator.mediaDevices) {
            scannerLoadError.textContent = "Browser is incompatible"
            scannerSettingsWrapper.classList.remove("d-none");
            scannerLoadError.classList.remove("d-none");
            return;
        }

        // ask permission to access the camera
        navigator.mediaDevices.getUserMedia({
            "video": {
                "facingMode": "environment",
                "width": { "ideal": 1920 },
                "height": { "ideal": 1080 },
            },
        })

        // access granted
        .then(function(stream) {

            // set the shared camera to virtual video element
            cameraVideo.srcObject = stream;

            // start scanning
            startVideoScan();
        })

        // error loading camera
        .catch(function(error) {

            // different error messages based on what went wrong
            switch(error.name) {

                // user didn't allow camera access
                case "NotAllowedError":
                    scannerLoadError.textContent = "Permission denied";
                    break;

                // no devices
                case "NotFoundError":
                    scannerLoadError.textContent = "No cameras found";
                    break;

                // catchall
                default:
                    scannerLoadError.textContent = "Error loading camera";
            }

            // show the error
            scannerSettingsWrapper.classList.remove("d-none");
            scannerLoadError.classList.remove("d-none");
        });
    }
    startScanIcon.addEventListener("click", useCameraScanner);
    scannerStartButton.addEventListener("click", useCameraScanner);

    // stop playing video and trying to scan images
    scannerStopButton.addEventListener("click", function() {

        // show the start camera icon
        startScanIcon.classList.remove("d-none");
        scannerImage.classList.add("d-none");
        scannerSettingsWrapper.classList.add("d-none");
        scannerToggles.classList.add("d-none");

        // stop the currently running video stream
        if (cameraVideo.srcObject) {
            cameraVideo.srcObject.getTracks().forEach(function(t) { t.stop(); });
        }
    });

    /***************************/
    /** Auto-Scan on Pageload **/
    /***************************/

    // the page's url looks like a verification code, so try to verify it
    if (window.location.href.match(vaxCodesV1MatchRegex) !== null) {

        // clicking to scan another code will cause a page refresh instead of showing the collapse area
        document.getElementById("scan-another-page-refresh").classList.remove("d-none");
        document.getElementById("scan-another").classList.add("d-none");

        // show the verifying state
        resultsPieces.forEach(function(el) { el.classList.add("d-none"); });
        alertPending.classList.remove("d-none");

        // try to verify the scanned code
        verifyCode(window.location.href,

            // success
            function(results) {
                // show the result
                showResults(results);
            },

            // error
            function(error) {
                // hide any existing results
                resultsPieces.forEach(function(el) { el.classList.add("d-none"); });

                // code isn't in the right format
                if (error['error'] === "invalidFormat") {
                    alertInvalidFormat.classList.remove("d-none");
                }
                // internal only issuer
                else if (error['error'] === "internalOnlyError") {
                    alertInternalError.classList.remove("d-none");
                }
                // couldn't find the issuer
                else if (error['error'] === "lookupError") {
                    lookupErrorIssuer.textContent = error['issuerId'];
                    alertLookupError.classList.remove("d-none");
                }
                // code signature verification failed
                else if (error['error'] === "invalidSignature") {
                    alertInvalidSignature.classList.remove("d-none");
                }
                // signature is expired
                else if (error['error'] === "expiredSignature") {
                    alertExpiredSignature.classList.remove("d-none");
                }
                // catch-all for unknown errors
                else {
                    alertUnknownError.classList.remove("d-none");
                }
            },
        );
    }

    // the page's url looks like an internal scan page, so display a warning
    const pubKeyParam = new RegExp("#(?:[^#]+\/|)pubkey=([^#=\/]+)");
    const pubKeyParamMatch = window.location.href.match(pubKeyParam);
    if (pubKeyParamMatch !== null) {
        try {
            let pubkeyAsc = window.atob(pubKeyParamMatch[1]);
            const pubKeyFmt = new RegExp("-----BEGIN PGP PUBLIC KEY BLOCK-----.+-----END PGP PUBLIC KEY BLOCK-----", "s");
            if (pubkeyAsc.match(pubKeyFmt) !== null) {
                // show warning
                alertInternalOnly.classList.remove("d-none");
            }
        } catch (err) {
            // do nothing if errored out
        }
    }

</script>
